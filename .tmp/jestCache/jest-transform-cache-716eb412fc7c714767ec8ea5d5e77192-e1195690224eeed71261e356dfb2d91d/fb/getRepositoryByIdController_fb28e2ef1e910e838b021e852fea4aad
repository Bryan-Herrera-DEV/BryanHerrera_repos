63023c324047fa0a8db8510a49fdd5d0
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRepositoryByIdController = void 0;
const repository_entitie_1 = require("../../entities/repository.entitie");
const tribe_entitie_1 = require("../../entities/tribe.entitie");
const http_status_1 = __importDefault(require("http-status"));
const axios_1 = __importDefault(require("axios"));
const json2csv_1 = require("json2csv");
class getRepositoryByIdController {
    getMock() {
        return __awaiter(this, void 0, void 0, function* () {
            const mock = process.env.SERVICE_MOCK_URL;
            if (mock) {
                const response = yield axios_1.default.get(mock);
                return response.data;
            }
            return null;
        });
    }
    makeRepositoryData(_data, _coverage, _repository) {
        return __awaiter(this, void 0, void 0, function* () {
            const mock = yield this.getMock();
            const data = _data;
            if (mock) {
                // console.log(JSON.stringify(data));
                // console.log(mock.repositories[0].state)
                mock.repositories.forEach((repository) => {
                    if (repository.id == data.id) {
                        data.verificationState = `${repository.state === 604
                            ? "Verificado"
                            : repository.state === 605
                                ? "En espera"
                                : "Aprobado"}`;
                    }
                });
                const state = _repository.state.toLocaleLowerCase();
                data.state = `${state === "e" ? "Habilitado" : state === "d" ? "Deshabilitado" : "Archivado"}`;
                return data;
            }
        });
    }
    makeResponse(id_repository, name, name_tribe, name_organization, metrics, repo) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {
                id: id_repository,
                name: name,
                tribe: name_tribe,
                organization: name_organization,
                coverage: `${metrics.coverage}%`,
                codeSmells: metrics.code_smells,
                bugs: metrics.bugs,
                vulnerabilities: metrics.vulnerabilities,
                hotspots: metrics.hotspot,
            };
            const nRes = yield this.makeRepositoryData(response, metrics.coverage, repo);
            return nRes;
        });
    }
    makeCSV(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const csv = yield (0, json2csv_1.parseAsync)(yield data, {
                delimiter: ",",
                fields: [
                    { value: "id" },
                    { value: "name" },
                    { value: "tribe" },
                    { value: "organization" },
                    { value: "coverage" },
                    { value: "codeSmells" },
                    { value: "bugs" },
                    { value: "vulnerabilities" },
                    { value: "hotspots" },
                    { value: "verificationState" },
                    { value: "state" },
                ],
                quote: "",
            });
            return {
                csv: Buffer.from(csv),
            };
        });
    }
    getRepositoryById(_req, res, id_tribe, name_tribe, name_organization, cs) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const repository = yield repository_entitie_1.Repository.findBy({
                    id_tribe: id_tribe,
                });
                if (!repository) {
                    res.status(http_status_1.default.NOT_FOUND).json({
                        status: "error",
                        message: "Repositorio no encontrado",
                    });
                }
                else {
                    // eslint-disable-next-line prefer-const
                    let response = [];
                    repository.forEach((rep, i) => __awaiter(this, void 0, void 0, function* () {
                        response.push(yield this.makeResponse(rep.id_repository, rep.name, name_tribe, name_organization, rep.metrics, rep));
                        if (i === repository.length - 1) {
                            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                if (cs === "n") {
                                    res.status(http_status_1.default.OK).json({
                                        data: yield response,
                                    });
                                }
                                else {
                                    res.header('Content-Type', 'text/csv');
                                    res.attachment('metrics.csv');
                                    res.send(yield this.makeCSV(response));
                                }
                            }), 100);
                        }
                    }));
                }
            }
            catch (error) {
                res.status(http_status_1.default.INTERNAL_SERVER_ERROR).json({
                    status: "error",
                    message: "Error al obtener el repositorio",
                    data: error,
                });
            }
        });
    }
    run(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tribe = yield tribe_entitie_1.Tribe.findOneBy({
                    id_tribe: parseInt(req.params.id_tribe),
                });
                if (!tribe) {
                    res.status(http_status_1.default.NOT_FOUND).json({
                        status: "error",
                        message: "Tribu no encontrada",
                    });
                }
                else {
                    this.getRepositoryById(req, res, parseInt(req.params.id_tribe), tribe.name, tribe.id_organization.name, "n");
                }
            }
            catch (error) {
                res.status(http_status_1.default.INTERNAL_SERVER_ERROR).json({
                    status: "error",
                    message: "Error al repositorio las tribus",
                    data: error,
                });
            }
        });
    }
    generateCSV(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tribe = yield tribe_entitie_1.Tribe.findOneBy({
                    id_tribe: parseInt(req.params.id_tribe),
                });
                if (!tribe) {
                    res.status(http_status_1.default.NOT_FOUND).json({
                        status: "error",
                        message: "Tribu no encontrada",
                    });
                }
                else {
                    yield this.getRepositoryById(req, res, parseInt(req.params.id_tribe), tribe.name, tribe.id_organization.name, "s");
                }
            }
            catch (error) {
                res.status(http_status_1.default.INTERNAL_SERVER_ERROR).json({
                    status: "error",
                    message: "Error al repositorio las tribus",
                    data: error,
                });
            }
        });
    }
}
exports.getRepositoryByIdController = getRepositoryByIdController;
